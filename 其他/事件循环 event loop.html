<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    js运行机制

    一、前言

    javascript是一门单线程的非阻塞的脚本语言。

    单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。

    而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）
    这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

    二、事件循环 event loop

    JavaScript语言将任务的执行分成两种：同步任务和异步任务。通过事件循环处理任务。

    1. 执行栈与任务队列

    当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。
    [这里说的同步代码应该就是所有任务按照顺序放执行栈中吧，同步是顺序的意思，不是同步任务的意思。因为看网上和这里的图以及文字，执行栈中包含同步任务和异步任务。其次，任务由主线程执行]
    (如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境
    中的代码 执行完毕并返回结果后，js会退出这个执行环境并吧这个执行环境销毁。接着继续执行执行栈里的下一段代码。)

    遇到一个异步任务后会将这个任务挂起，继续执行执行栈中的其他任务。当一个异步任务返回结果后，js会将这个任务加入与当前执行
    栈不同的另一个队列，我们称之为任务队列。被放入任务队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于
    闲置状态时，主线程会去查找任务队列是否有任务。如果有，那么主线程会从中取出排在第一位的任务，并把对应的回调放入执行栈中，执行其
    中的同步代码。如此反复，进入循环。

    <img src="事件循环.jpg" alt="">

    <script>
        console.log('A' + new Date());
        setTimeout(function () {
            console.log('B' + new Date());
        }, 1000);
        console.log('～')
        var end = Date.now() + 3000;
        while (Date.now() < end) {}
        console.log('C' + new Date());
    </script>
    A,B,C输出的顺序，以及输出的时间 ?
    A会被立即输出，执行到setTimeout(...)时，将这个任务挂起（将会等待1秒后在任务队列添加一个打印B的任务）继续往下执行（所以～紧跟A后输出）。
    JS主线程会在while循环通过后继续往下执行，在等待3秒后C被打印，此时任务队列中还有个定时任务回调函数。JS执行栈执行完一个任务之后会再去
    任务队列取任务，所以C输出后，直接输出B。

    一定要清楚，setTimeout(..)它所做的是设定一个定时器，当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时
    刻的tick会摘下并执行这个回调。如果这时候事件循环中已经有20个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有
    抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..)定时器的精度可能不高。

    2.宏任务和微任务

    根据这个异步事件的类型，这个事件实际上会被加入对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，会立刻先处理所有
    微任务队列中的事件，然后再去宏任务队列中取出一个事件，把对应的回调加入当前执行栈。

    宏任务：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering
    微任务：process.nextTick, Promises, Object.observe, MutationObserver,MessageChannel


</body>

</html>