<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    // Promise是异步编程的一种解决方案。里面可以放一些异步操作。

    let promise = new Promise(function (resolve,reject) {
        if(){//异步操作成功，调用resolve，并将异步操作的结果，作为参数传递出去
            resolve(value)//将Promise对象的状态从“未完成”变为“成功”
        }else{//异步操作失败（抛出错误），调用reject，并将异步操作报出的错误，作为参数传递出去。
            reject(error)//将Promise对象的状态从“未完成”变为“失败”
        }
    })
    promise.then(function (value) { // Promise对象的状态变为resolved时就会触发then的第一个回掉函数
        console.log(value)
    },function (error) { // Promise对象的状态变为rejected时就会触发then的第二个回掉函数
        console.log(error)
    })

    // (因为Promise的这些特性，所以Promise可以解决异步编程，将异步操作以同步操作的流程表达出来)



    /*
    Promise传入的函数是会立刻执行的吗？
    Promise新建后就会立即执行，所以传入的函数是会立刻执行的。且无法中途取消。

    promise对象有三种状态：pending进行中，fulfilled已完成，rejected已失败。

    若调用了两次resolve方法会怎么样？
    状态一旦改变，就不会再变，任何时候都可以得到这个结果。所以第二次调用resolve没什么用，也会立即得到这个结果
    (第二次调用resolve相当于没有任何用处，也不会再触发then的第一个回掉函数)
    */


    
    // 中断Promise的执行：return resolve
    new Promise((resolve, reject) => {
        return resolve(1);
        // 后面的语句不会执行
        console.log(2);
    })
    /* 
    一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，
    而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。
    */

    </script>
</body>
</html>