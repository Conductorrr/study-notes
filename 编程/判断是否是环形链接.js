// 环形链表 o

// 只要判断有没有指向NULL的指针就好了。如果有指向NULL的指针，就不是环形链表
// 如果直到又碰到头结点都没有指向NULL的指针，那就是循环链表





// 带环的链表 6型

// 法1 龟兔赛跑
// 定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。
// 如果走得快的指针追上了走得慢的指针，那么链表就是环形链表；
// 如果走得快的指针走到了链表的末尾（next指向 NULL）都没有追上第一个指针，那么链表就不是环形链表。


// 法2
// 将所有的遍历过的节点用某个结构存储起来，然后每遍历一个节点，都在这个结构中查找是否遍历过，如果找到有重复，则说明该链表存在循环；
// 如果直到遍历结束，则说明链表不存在循环。

// 这个结构我们可以使用hash来做，hash中存储的值为节点的内存地址，

// 所以整个算法的时间复杂度为O(n)，空间复杂度为O(n)。