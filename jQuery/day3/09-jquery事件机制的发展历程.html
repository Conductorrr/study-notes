<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    #box {
      width: 500px;
      height: 500px;
      background-color: pink;
    }
  </style>
</head>
<body>

<!--点击按钮，在div里面创建一个新的p元素-->
<input type="button" value="按钮" id="btn">

<div id="box">
  <div>
    <span>呵呵</span>
    <p>11111</p>
    <p>22222</p>
    <p>33333</p>
    <p>44444</p>
  </div>
</div>


<script src="jquery-1.12.4.js"></script>
<script>
  //$("div").children("p").click(function(){})
  
  $(function () {
    
      //简单事件,给自己注册的事件      缺点：一次只能注册一个事件
//    $("div").click(function () {
//      alert("哈哈");
//    });


      //bind方式  一次可以注册多个事件
//    $("p").bind("click mouseenter",function () {  });
//    $("p").bind({
//      click:function () {
//        alert("呵呵")
//      },
//      mouseenter:function () {
//        alert("哈哈")
//      }
//    });
    
    
    $("#btn").click(function () {
      $("<p>我是新增加的p元素</p>").appendTo("div");
    });
    //简单事件、bind方法的问题，新增加的p元素没有注册上事件
  
    
    //delegate:代理、委托事件
    //给父元素注册委托事件，最终还是由子元素来执行。
    
    //要给div注册一个委托事件,但是最终不是由div执行，而是由p执行
    //第一个参数：selector:事件最终由谁来执行。
    //第二个参数：事件的类型
    //第三个参数：函数，要做什么
    $("#box").delegate("p", "click", function () {
      //alert("呵呵");
      console.log(this);
    });
    //优点：动态创建的也能有事件   缺点：只能注册委托事件
    //（p元素接收到click事件时，会把接收到的事件传给父元素(事件冒泡)，父元素的事件触发，做的事情就是让子元素执行事件处理程序
  
  });
</script>

</body>
</html>